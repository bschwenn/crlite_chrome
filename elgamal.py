import argparse
import json
import os
import random
from number_theory import *
from key_generator import generate_and_write_keys

SEARCH_INTERVAL = 1000
SMALL_PRIMES_BOUND = 10000
SIG_OUTPUT_FILE = 'message.sig'

class ElGamalPublicKey:
    def __init__(self, prime, generator, power):
        self.prime = prime
        self.generator = generator
        self.power = power

class SignedMessage:
    def __init__(self, message, random_int, signature):
        self.message = message
        self.random_int = random_int
        self.signature = signature

    # From file constructor
    def from_file():
        data = {}

        with open(SIG_OUTPUT_FILE) as data_file:
            data = json.load(data_file)

        return SignedMessage(data['message'], data['int'], data['sig'])

    def write_to_file(self):
       f = open(SIG_OUTPUT_FILE, 'w')
       data = { 'message': self.message, 'int': self.random_int, 'sig': self.signature }
       with open(SIG_OUTPUT_FILE, 'w') as outfile:
           json.dump(data, outfile)

def text_to_int(text):
    result = 0

    for c in text:
        result = result + ord(c)

    return result

def int_to_text(num):
    result = ''
    str_num = str(num)

    for k in range(0, len(str_num), 2):
        result = result + chr(int(str_num[k:k+3]))

    return result

def sign(message, public_key, private_key):
    num_msg = text_to_int(message)
    start = random.randrange(2+SEARCH_INTERVAL, public_key.prime-1-SEARCH_INTERVAL)
    search_list = sieve_in_range(sieve_era(SMALL_PRIMES_BOUND), start, start+SEARCH_INTERVAL)
    k = 1

    # Should keep searching if none work (very unlikely)
    for candidate in search_list:
        if gcd(candidate, public_key.prime-1) == 1:
            k = candidate
            break

    r = pow(public_key.generator, k, public_key.prime)
    k_inv = prime_mod_inv(k, public_key.prime)
    sig = (k_inv*(num_msg - private_key*r)) % (public_key.prime-1)

    return SignedMessage(num_msg, r, sig)

def verify(signed_message, public_key):
    v1 = (pow(public_key.power, signed_message.random_int, public_key.prime) * pow(signed_message.random_int, signed_message.signature, public_key.prime)) % (public_key.prime)
    v2 = pow(public_key.generator, signed_message.message, public_key.prime)
    print(v1, v2)
    print(public_key.power, signed_message.random_int)
    return v1 == v2

def main():
    parser = argparse.ArgumentParser(description='ElGamal signature generator. Produces a signed message in message.sig. Uses keys generated by key_generator.py.')
    parser.add_argument('--message', type=str, help='The message to sign.', default='Default message.')
    parser.add_argument('--verify', dest='verify', action='store_true', help='Verify that the signature file message.sig is valid for a_key.priv.')
    args = parser.parse_args()

    if not os.path.isfile('key.pub'):
        # Call the key generator with default settings (30 digits)
        generate_and_write_keys(30)

    # Read JSON file
    pub_dict = {}
    with open('key.pub') as data_file:
        pub_dict= json.load(data_file)

    prime = pub_dict['prime']
    generator = pub_dict['generator']
    priv_key_a = None

    with open('a_key.priv', 'r') as data_file:
        priv_key_a = int(data_file.read())

    g_to_a = pow(generator, priv_key_a, prime)

    print("Using public key ({}, {}, {})".format(prime, generator, g_to_a))
    key = ElGamalPublicKey(prime, generator, g_to_a)

    if args.verify:
        # Read from the file
        sig = SignedMessage.from_file()

        if verify(sig, key):
            print('The signature is valid!')
        else:
            print('The signature is NOT valid!')
    else:
        message = args.message
        sig = sign(message, key, priv_key_a)
        sig.write_to_file()
        print('The signed message was output to', SIG_OUTPUT_FILE)

if __name__ == '__main__':
    main()
